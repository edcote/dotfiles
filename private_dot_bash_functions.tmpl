confirm() {
  read -r -p "${1:-Are you sure? [y/N]} " response
  case "$response" in
    [yY][eE][sS]|[yY]) true ;;
    *) false ;;
  esac
}

{{- if eq .chezmoi.osRelease.versionID "rodete" }}
gcert() {
  [[ -n "${TMUX:-}" ]] && eval $(tmx2 show-environment -s)
  command gcert "$@"
}

gcertstatus() {
  [[ -n "${TMUX:-}" ]] && eval $(tmx2 show-environment -s)
  command gcertstatus "$@"
}

g4cleansync() {
  if ! [[ -d ${PWD%/google3*}/.citc ]]; then
    echo "ERROR: Not in g3 client" >&2
    return 1
  fi
  g4 status
  if confirm; then
    g4 revert //...
    g4 sync
  fi
}

hgcleansync() {
  if ! grep -s -q fig ${PWD%/google3*}/.hg/requires; then
    echo "ERROR: Not in fig client" >&2
    return 1
  fi
  hg status
  if confirm; then
    hg revert --all
    hg sync
  fi
}
export -f hgcleansync
{{- end }}

{{- if (contains "google" .chezmoi.homeDir) }}
go_sunglass() {
  local number=${1:-1}
  local branch=${2:-rdo}
  local gitroot="${HOME}/gitrepos/sunglass${branch}_${number}"

  pushd -n "${gitroot}/hardware/tb" >& /dev/null
  pushd -n "${gitroot}/hardware/traces" >& /dev/null
  pushd -n "${gitroot}/hardware/test/unit/isp_tracer" >& /dev/null
  pushd -n "${gitroot}/common/test" >& /dev/null
  pushd -n "${gitroot}/hardware/scripts/rtl_gen" >& /dev/null
  pushd -n "${gitroot}" >& /dev/null
  cd "${gitroot}"
  dirs -v
}
export -f go_sunglass

go_mlb() {
  local number=${1:-0}
{{- if eq .chezmoi.osRelease.versionID "rodete" }}
  cd "${HOME}/repos/mlb_${number}"
{{- else }}
  cd "/google/gchips/workspace/redondo-us/cbf/user/${USER}/repos/mlb_${number}"
{{- end }}
}
export -f go_mlb
{{- end }}

gitcleansync() {
  if ! [[ -d .git ]]; then
    echo "ERROR: Not in git root directory" >&2
    return 1
  fi
  git status
  if confirm; then
    git clean -fdx
    git pull --rebase
    git submodule update --init --recursive
  fi
}

repocleansync() {
  if ! [[ -d .repo ]]; then
    echo "ERROR: Not in repo top directory" >&2
    return 1
  fi
  repo forall -c 'git status'
  if confirm; then
    repo forall -c 'git clean -fdx'
    repo forall -c 'git pull --rebase'
  fi
}
export -f repocleansync

rmbg() {
  if confirm; then
    local tmp=$(mktemp)
    mv $* ${tmp}
    \rm -rf $*
    \rm -rf ${tmp}
  fi
}

ssh-agent-add() {
  local key=$1
  [[ -n ${key} ]] || key=${HOME}/.ssh/my_very_secure_key
  ssh-add "${key}"
}

ssh-agent-list() {
  if ssh-agent-alive; then
    ssh-add -l
  else
    echo "ssh-agent not available, run ssh-agent-start?" >&2
  fi
}

# exit code 0: agent is running
# exit code 1: agent is running but has no keys
ssh-agent-alive() {
  ssh-add -l >& /dev/null
  [[ $? -lt 2 ]]
}

ssh-agent-start() {
  local ssh_env=~/.ssh-agent.env

  # First, try with SSH_AUTH_SOCK and SSH_AUTH_PID
  if [[ -n ${SSH_AUTH_SOCK} ]]; then
    if ssh-agent-alive; then
      echo "ssh-agent already running" >&2
      return 0
    fi
  fi

  # Try using ssh_env file
  if [[ -e ${ssh_env} ]]; then
    source "${ssh_env}"
    if ssh-agent-alive; then
      echo "ssh-agent already running, updated environment" >&2
      return 0
    fi
  fi

  # Create new ssh-agent
  ssh-agent -s > "${ssh_env}" && source "${ssh_env}"
}

# Prepends directory to PATH
pathadd() {
  if [[ -d "$1" ]] && [[ ":$PATH:" != *":$1:"* ]]; then
    PATH="$1${PATH:+":$PATH"}"
  fi
}

# Adds directory to stack and print
function p() {
  local d=${1:-.}
  pushd "${d}" >& /dev/null || return 1
  dirs -v
}
